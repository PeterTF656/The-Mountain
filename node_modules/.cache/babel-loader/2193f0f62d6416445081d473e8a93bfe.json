{"ast":null,"code":"//  Triangulation sets of three\nexport const TRIANGULATION = [127, 34, 139]; // Triangle drawing method\n\nconst drawPath = (ctx, points, closePath) => {\n  const region = new Path2D();\n  region.moveTo(points[0][0], points[0][1]);\n\n  for (let i = 1; i < points.length; i++) {\n    const point = points[i];\n    region.lineTo(point[0], point[1]);\n  }\n\n  if (closePath) {\n    region.closePath();\n  }\n\n  ctx.strokeStyle = \"grey\";\n  ctx.stroke(region);\n}; // Drawing Mesh\n\n\nexport const drawEyeMesh = (predictions, ctx) => {\n  if (predictions.length > 0) {\n    predictions.forEach(prediction => {\n      const keypoints = prediction.scaledMesh; //  Draw Triangles\n\n      for (let i = 0; i < TRIANGULATION.length / 3; i++) {\n        // Get sets of three keypoints for the triangle\n        const points = [TRIANGULATION[i * 3], TRIANGULATION[i * 3 + 1], TRIANGULATION[i * 3 + 2]].map(index => keypoints[index]); //  Draw triangle\n\n        drawPath(ctx, points, true);\n      } // Draw Dots\n\n\n      for (let i = 0; i < keypoints.length; i++) {\n        const x = keypoints[i][0];\n        const y = keypoints[i][1];\n        ctx.beginPath();\n        ctx.arc(x, y, 1\n        /* radius */\n        , 0, 3 * Math.PI);\n        ctx.fillStyle = \"aqua\";\n        ctx.fill();\n      }\n    });\n  }\n};","map":{"version":3,"sources":["/Users/zelinpu/Dev/FacialLandmarkDetection/src/eyeStepOne.js"],"names":["TRIANGULATION","drawPath","ctx","points","closePath","region","Path2D","moveTo","i","length","point","lineTo","strokeStyle","stroke","drawEyeMesh","predictions","forEach","prediction","keypoints","scaledMesh","map","index","x","y","beginPath","arc","Math","PI","fillStyle","fill"],"mappings":"AAAA;AACA,OAAO,MAAMA,aAAa,GAAG,CACzB,GADyB,EAEzB,EAFyB,EAGzB,GAHyB,CAAtB,C,CAML;;AACA,MAAMC,QAAQ,GAAG,CAACC,GAAD,EAAMC,MAAN,EAAcC,SAAd,KAA4B;AAC3C,QAAMC,MAAM,GAAG,IAAIC,MAAJ,EAAf;AACAD,EAAAA,MAAM,CAACE,MAAP,CAAcJ,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,CAAd,EAA4BA,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,CAA5B;;AACA,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,MAAM,CAACM,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC,UAAME,KAAK,GAAGP,MAAM,CAACK,CAAD,CAApB;AACAH,IAAAA,MAAM,CAACM,MAAP,CAAcD,KAAK,CAAC,CAAD,CAAnB,EAAwBA,KAAK,CAAC,CAAD,CAA7B;AACD;;AAED,MAAIN,SAAJ,EAAe;AACbC,IAAAA,MAAM,CAACD,SAAP;AACD;;AACDF,EAAAA,GAAG,CAACU,WAAJ,GAAkB,MAAlB;AACAV,EAAAA,GAAG,CAACW,MAAJ,CAAWR,MAAX;AACD,CAbD,C,CAeA;;;AACA,OAAO,MAAMS,WAAW,GAAG,CAACC,WAAD,EAAcb,GAAd,KAAsB;AAC/C,MAAIa,WAAW,CAACN,MAAZ,GAAqB,CAAzB,EAA4B;AAC1BM,IAAAA,WAAW,CAACC,OAAZ,CAAqBC,UAAD,IAAgB;AAClC,YAAMC,SAAS,GAAGD,UAAU,CAACE,UAA7B,CADkC,CAGlC;;AACA,WAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,aAAa,CAACS,MAAd,GAAuB,CAA3C,EAA8CD,CAAC,EAA/C,EAAmD;AACjD;AACA,cAAML,MAAM,GAAG,CACbH,aAAa,CAACQ,CAAC,GAAG,CAAL,CADA,EAEbR,aAAa,CAACQ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAFA,EAGbR,aAAa,CAACQ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAHA,EAIbY,GAJa,CAIRC,KAAD,IAAWH,SAAS,CAACG,KAAD,CAJX,CAAf,CAFiD,CAOjD;;AACApB,QAAAA,QAAQ,CAACC,GAAD,EAAMC,MAAN,EAAc,IAAd,CAAR;AACD,OAbiC,CAelC;;;AACA,WAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,SAAS,CAACT,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACzC,cAAMc,CAAC,GAAGJ,SAAS,CAACV,CAAD,CAAT,CAAa,CAAb,CAAV;AACA,cAAMe,CAAC,GAAGL,SAAS,CAACV,CAAD,CAAT,CAAa,CAAb,CAAV;AAEAN,QAAAA,GAAG,CAACsB,SAAJ;AACAtB,QAAAA,GAAG,CAACuB,GAAJ,CAAQH,CAAR,EAAWC,CAAX,EAAc;AAAE;AAAhB,UAA8B,CAA9B,EAAiC,IAAIG,IAAI,CAACC,EAA1C;AACAzB,QAAAA,GAAG,CAAC0B,SAAJ,GAAgB,MAAhB;AACA1B,QAAAA,GAAG,CAAC2B,IAAJ;AACD;AACF,KAzBD;AA0BD;AACF,CA7BM","sourcesContent":["//  Triangulation sets of three\nexport const TRIANGULATION = [\n    127,\n    34,\n    139,\n  ];\n  \n  // Triangle drawing method\n  const drawPath = (ctx, points, closePath) => {\n    const region = new Path2D();\n    region.moveTo(points[0][0], points[0][1]);\n    for (let i = 1; i < points.length; i++) {\n      const point = points[i];\n      region.lineTo(point[0], point[1]);\n    }\n  \n    if (closePath) {\n      region.closePath();\n    }\n    ctx.strokeStyle = \"grey\";\n    ctx.stroke(region);\n  };\n  \n  // Drawing Mesh\n  export const drawEyeMesh = (predictions, ctx) => {\n    if (predictions.length > 0) {\n      predictions.forEach((prediction) => {\n        const keypoints = prediction.scaledMesh;\n  \n        //  Draw Triangles\n        for (let i = 0; i < TRIANGULATION.length / 3; i++) {\n          // Get sets of three keypoints for the triangle\n          const points = [\n            TRIANGULATION[i * 3],\n            TRIANGULATION[i * 3 + 1],\n            TRIANGULATION[i * 3 + 2],\n          ].map((index) => keypoints[index]);\n          //  Draw triangle\n          drawPath(ctx, points, true);\n        }\n  \n        // Draw Dots\n        for (let i = 0; i < keypoints.length; i++) {\n          const x = keypoints[i][0];\n          const y = keypoints[i][1];\n  \n          ctx.beginPath();\n          ctx.arc(x, y, 1 /* radius */, 0, 3 * Math.PI);\n          ctx.fillStyle = \"aqua\";\n          ctx.fill();\n        }\n      });\n    }\n  };"]},"metadata":{},"sourceType":"module"}